'use strict'

exports.generate = generate

const fs = require('fs')
const path = require('path')

const viz = require('viz.js')

const Pkg = require('./pkg')
const nsolidCLI = require('./nsolid-cli')

const HtmlTemplateName = path.join(__dirname, 'template.html')
const HtmlTemplate = fs.readFileSync(HtmlTemplateName, 'utf8')

// A default callback function.
function defaultCB (err, doc) {
  console.error('in default callback:')
  if (err != null) return console.error(err.stack)

  console.error(doc)
}

// Generate a diagram for an app or id
function generate (appArg, opts, cb) {
  opts = opts || {}
  opts.cb = cb || defaultCB

  nsolidCLI.run('info', function (err, infos) {
    if (err) {
      console.error('error running `nsolid-cli info`:', err.message)
      return opts.cb(err)
    }

    if (appArg == null) {
      console.error('use --help to print help')
      console.error('')
      printAppsAndIds(infos)
      return opts.cb()
    }

    let id
    let app = appArg

    for (let info of infos) {
      if (info == null || info.app == null) continue

      if (app === info.app) {
        id = info.id
        break
      }

      if (app === info.id) {
        id = info.id
        app = info.app
        break
      }
    }

    if (id == null) {
      console.error(`unknown app or id: ${appArg}`)
      console.error('')
      printAppsAndIds(infos)
      return opts.cb()
    }

    getPackageInfo(app, id, opts)
  })
}

// Get the package information for a specific app.
function getPackageInfo (app, id, opts) {
  nsolidCLI.run('package_info', app, id, function (err, packageInfo) {
    if (err) {
      console.error('error running `nsolid-cli info`', err)
      return opts.cb(err)
    }

    processPackageInfo(app, id, packageInfo, opts)
  })
}

// Process the package info.
function processPackageInfo (app, id, packageInfo, opts) {
  if (!packageInfo.packages) throw new Error('expecting packages property')

  // create the graph data structure
  const pkgGraph = Pkg.createGraph(packageInfo.packages)

  // collect the packages per grouping option
  let pkgs
  switch (opts.group) {
    case 'package':
      pkgs = pkgGraph.getPackagesByName()
      break
    case 'version':
      pkgs = pkgGraph.getPackagesByVersion()
      break
    case 'path':
      pkgs = pkgGraph.getPackagesByPath()
      break
    default:
      return opts.cb(new Error(`unknown grouping: ${opts.group}`))
  }

  // start building the Graphviz dot file
  const date = new Date()
    .toISOString()
    .replace('T', ' ')
    .replace(/-/g, '/')
    .substr(0, 19) + ' UTC'

  const dotLines = [`
digraph packages {
    comment = "Generated by https://github.com/pmuellr/ns-package-graph on ${date}";
    label = "generated by https://github.com/pmuellr/ns-package-graph on ${date}";
    labelloc = b;
    concentrate = true;
    smoothing = avg_dist;
    node [
       style = filled,
       color = "#00FF00",
       shape = polygon,
       sides = 6,
       orientation = 30.0,
       penwidth = 2,
       regular = true
    ];
    edge [
       color = "#7F7FFF",
       penwidth = 2
    ];
`.trim()]

  // write the package dependency connections
  for (let pkg of pkgs) {
    for (let dep of pkg.deps) {
      let from
      let to

      if (opts.child === 'dep') {
        from = pkg
        to = dep
      } else {
        from = dep
        to = pkg
      }

      const tooltip = `${from.name} -> ${to.name}`
      dotLines.push(`    pkg_${from.id} -> pkg_${to.id} [`)
      dotLines.push(`        tooltip = "${tooltip}"`)
      dotLines.push('    ];')
    }
  }
  dotLines.push('')

  // write the package attributes
  for (let pkg of pkgs) {
    const label = `label = "${getPkgLabel(pkg)}"`
    const color = `fillcolor = "#${getPkgColor(pkg)}"`
    const sideColor = `color = "#${getPkgSideColor(pkg)}"`
    const url = `URL = "https://www.npmjs.com/package/${pkg.name}"`
    const tooltip = `tooltip = "${getPkgTooltip(pkg)}"`

    dotLines.push(`    pkg_${pkg.id} [`)
    dotLines.push(`        ${label},`)
    dotLines.push(`        ${color},`)
    dotLines.push(`        ${sideColor},`)
    dotLines.push(`        ${url},`)
    dotLines.push(`        ${tooltip}`)
    dotLines.push('    ];')
  }

  dotLines.push('}')

  const dotFile = dotLines.join('\n')
  if (opts.format === 'dot') return opts.cb(null, dotFile)

  const svg = viz(dotFile)
  if (opts.format === 'svg') return opts.cb(null, svg)

  if (opts.format === 'html') {
    const html = `${HtmlTemplate}\n${svg}`
    return opts.cb(null, html)
  }

  if (opts.format === 'data-url') {
    const svgBase64 = new Buffer(svg).toString('base64')
    const svgDataUrl = `data:image/svg+xml;base64,${svgBase64}`
    return opts.cb(null, svgDataUrl)
  }

  opts.cb(null, svg)
}

// Return a tooltip for a package
function getPkgTooltip (pkg) {
  const tooltip = [ pkg.name ]

  tooltip.push()
  tooltip.push(`versions: ${pkg.versions.join(', ')}`)
  tooltip.push('paths:')
  for (let path of pkg.paths) {
    tooltip.push(`- ${path}`)
  }

  // return tooltip.join('\n')
  // return tooltip.join('\r')
  return tooltip.join('&#013;')
}

// Return a color for a package
function getPkgColor (pkg) {
  if (pkg.versionCopies !== 1) return 'FFA0A0'
  if (pkg.nameCopies !== 1) return 'FFFFA0'
  return 'F7FFF7'
}

// Return a color for a package side
function getPkgSideColor (pkg) {
  if (pkg.versionCopies !== 1) return 'FF0000'
  if (pkg.nameCopies !== 1) return '00FF00'
  return '00FF00'
}

// Return a label for a package
function getPkgLabel (pkg) {
  // const name = pkg.name.replace(/-/g, '-\\n') + '\\n'
  const name = splitPkgName(pkg.name)
  const versions = pkg.versions.join('\\n')
  const paths = pkg.versionCopies
  const pathCopies = paths === 1 ? '' : `\\n${paths} copies`

  return `${name}\\n${versions}${pathCopies}`
}

// Split a package name nicely.
function splitPkgName (pkgName) {
  // if name is <= 10 chars, just use it as is
  if (pkgName.length <= 10) return pkgName

  // otherwise, iterate through chars, separating nicely
  const parts = []
  let part = ''

  for (let c of pkgName) {
    part += c

    // if not a separator, continue
    if (['-', '_'].indexOf(c) === -1) continue

    // if the current part length < 6, continue
    if (part.length < 6) continue

    // finish a part, start a new one
    parts.push(part)
    part = ''
  }

  // if there's a hanging part, <= 4 chars, append it to previous
  if (part !== '' && parts.length > 0 && part.length <= 3) {
    parts[parts.length - 1] += part
  } else {
    parts.push(part)
  }

  return parts.join('\\n')
}

// Print the current apps and ids.
function printAppsAndIds (infos) {
  console.error('available apps:')
  infos = infos.filter((info) => info)
  const apps = new Set(infos.map((info) => info.app))
  for (let app of apps) {
    console.error(`   ${app}`)
  }

  console.error('')
  console.error('available ids:')
  for (let info of infos) {
    console.error(`   ${info.id}  (app: ${info.app})`)
  }
}
